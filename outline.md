poa:
===
1. collect assets from book, kay speech
2. put into rough form
3. learn act-r enough for demo + install on m/c if reqd
4. polish story

things to tell
==============
- why such a theory
- bits of the elephant
	- visualizations: code city, codemaps
	- micro theories/best practices
- gutse
	- example
- guts
- nature of the theory
	- useful, not necessarily provable
- emperical evidence

how to tell
===========
- hook: bring them in
	- show "whats in it for me"
- show, dont tell
	- show code
	- keep tell bits very short

story
=====
- how many of you are:
	- "enterprise" developers
	- web developers
	- architects
	- ...
	- ...
	- language theorists
- how many of you think these are true:
	- list of well known aphorisms/best practices here with simple hand raisable answers
- how many of you use these terms about your software:
	- stable
	- flexible
	- reusable
	- scalable
 .. but mean it only in a hand-wavy kind of way?
 - the case for a unified theory:
 	- we're in the prescience stage with software engineering
 	- a common vocabulary will help unify concepts
 	- a common set of laws will help predict outcomes
 	- sw dev is inherently a "lossy" process, so having a way to THINK about it is useful.
 		- pensieve
 		- the most important thing - the why - is lost
 - examples of micro theories:
 	- MMM
 	- TDD etc
 	- Visualizations
 - digression: my path to GUTS
 	- original idea of FEM for software
 	- Alan Kay's idea of "Architecture on a t-shirt"
 	- Waitaminnit moment
 	- GUTSE
 - so the key difference between physical theories and a TSE
 	- no physical limits
 	- inclusion of the mind
 	- the resulting subjectivity
 - without further ado: GUTSE
 	- problem solving is a mapping from a problem space to a solution space
 		- or the problem+solution space ie the domain
 		- real world wrinkle: there are no transformations, only transformers
 	- given a problem, SE problems are problems such that:
 		problem space: problems that can be solved by a machine: P,NP etc
 		transformer: human mind(s)
 		solution space+problem space: code
 		transformer: machine
 		solution space: running code
 	- so all sw engg is transformation.
 	- any transformer that "just does it" instead of translate to another spec is an executor
 	- machine: structure and behavior
 	- man : structure and behavior
 	- many machines
 	- many men
 	- combining man and machine
 - the "so what":
 	- a common language to model not just the software, but how we build it
 	- an "executable" model of the mind
 	- things to be taken for granted:
 		- human minds will be involved in the building
 		- subjectivity is brought into the act of sw dev because of this
 		- so always talk in terms of the semantic domain being used to state anything
 	- things that can be proven:
 		- given a specific SD, you can prove:
 			- class of problems based on interaction between man and machine
 			- class of problems based on interaction between man and man
 			- class of problems based on interaction between machine and machine
 - guts:
 	